
// To generate this file run: re2c -b -i -w RelevanceLexer.re2c > RelevanceLexer.cpp

#include "RelevanceLexer.h"

RelevanceLexer::RelevanceLexer()
{
	Reset();
}

void RelevanceLexer::Reset()
{
	m_start = 0;
	m_end = 0;
	m_cursor = 0;
	m_marker = 0;
	m_ctxmarker = 0;
}

RelevanceToken RelevanceLexer::NextToken()
{
	m_marker    = m_cursor;
	m_ctxmarker = m_cursor;

/*!re2c
	re2c:define:YYCTYPE      = UTF16::Unit;
	re2c:define:YYCURSOR     = m_cursor;
	re2c:define:YYLIMIT      = m_end;
	re2c:define:YYMARKER     = m_marker;
	re2c:define:YYCTXMARKER  = m_ctxmarker;
	re2c:define:YYFILL:naked = 1;
	re2c:define:YYFILL       = "{ Fill(); }";

	ws           = '\t' | '\r' | '\n' | ' ';
	ignored      = 'a' | 'an' | 'the';
	keywordspace = ws+ ( ignored ws+ )*;
	ks           = keywordspace;
	nonword      = [^0-9a-zA-Z_'] | [\000];
	nw           = nonword;
	word         = [a-zA-Z_][0-9a-zA-Z_']*;
	any          = [\000-\377];

	ws+         { return RelevanceToken::t_whitespace; }
	[0-9]+      { return RelevanceToken::t_number; }
	["][^"]*["] { return RelevanceToken::t_string; }

	word        { return RelevanceToken::t_word; }

	"("         { return RelevanceToken::t_openParen; }
	")"         { return RelevanceToken::t_closeParen; }

	"!="        { return RelevanceToken::t_notEqual; }
	"&"         { return RelevanceToken::t_concat; }
	"*"         { return RelevanceToken::t_star; }
	"+"         { return RelevanceToken::t_plus; }
	","         { return RelevanceToken::t_comma; }
	"-"         { return RelevanceToken::t_minus; }
	"/"         { return RelevanceToken::t_slash; }
	";"         { return RelevanceToken::t_semiColon; }
	"<"         { return RelevanceToken::t_less; }
	"<="        { return RelevanceToken::t_lessOrEqual; }
	"="         { return RelevanceToken::t_equal; }
	">"         { return RelevanceToken::t_greater; }
	">="        { return RelevanceToken::t_greaterOrEqual; }

	'a'                                                             /nw { return RelevanceToken::t_ignored; }
	'an'                                                            /nw { return RelevanceToken::t_ignored; }
	'the'                                                           /nw { return RelevanceToken::t_ignored; }

	'and'                                                           /nw { return RelevanceToken::t_and; }
	'as'                                                            /nw { return RelevanceToken::t_as; }
	'contains'                                                      /nw { return RelevanceToken::t_contains; }
	'does' ks 'not' ks 'contain'                                    /nw { return RelevanceToken::t_notContains; }
	'does' ks 'not' ks 'end' ks 'with'                              /nw { return RelevanceToken::t_notEndsWith; }
	'does' ks 'not' ks 'equal'                                      /nw { return RelevanceToken::t_notEqual; }
	'does' ks 'not' ks 'start' ks 'with'                            /nw { return RelevanceToken::t_notStartsWith; }
	'else'                                                          /nw { return RelevanceToken::t_else; }
	'ends' ks 'with'                                                /nw { return RelevanceToken::t_endsWith; }
	'equals'                                                        /nw { return RelevanceToken::t_equal; }
	'exist'                                                         /nw { return RelevanceToken::t_exists; }
	'exist' ks 'no'                                                 /nw { return RelevanceToken::t_notExists; }
	'exists'                                                        /nw { return RelevanceToken::t_exists; }
	'exists' ks 'no'                                                /nw { return RelevanceToken::t_notExists; }
	'false'                                                         /nw { return RelevanceToken::t_false; }
	'if'                                                            /nw { return RelevanceToken::t_if; }
	'is'                                                            /nw { return RelevanceToken::t_equal; }
	'is' ks 'contained' ks 'by'                                     /nw { return RelevanceToken::t_containedBy; }
	'is' ks 'equal' ks 'to'                                         /nw { return RelevanceToken::t_equal; }
	'is' ks 'greater' ks 'than'                                     /nw { return RelevanceToken::t_greater; }
	'is' ks 'greater' ks 'than' ks 'or' ks 'equal' ks 'to'          /nw { return RelevanceToken::t_greaterOrEqual; }
	'is' ks 'less' ks 'than'                                        /nw { return RelevanceToken::t_less; }
	'is' ks 'less' ks 'than' ks 'or' ks 'equal' ks 'to'             /nw { return RelevanceToken::t_lessOrEqual; }
	'is' ks 'not'                                                   /nw { return RelevanceToken::t_notEqual; }
	'is' ks 'not' ks 'contained' ks 'by'                            /nw { return RelevanceToken::t_notContainedBy; }
	'is' ks 'not' ks 'equal' ks 'to'                                /nw { return RelevanceToken::t_notEqual; }
	'is' ks 'not' ks 'greater' ks 'than'                            /nw { return RelevanceToken::t_notGreater; }
	'is' ks 'not' ks 'greater' ks 'than' ks 'or' ks 'equal' ks 'to' /nw { return RelevanceToken::t_notGreaterOrEqual; }
	'is' ks 'not' ks 'less' ks 'than'                               /nw { return RelevanceToken::t_notLess; }
	'is' ks 'not' ks 'less' ks 'than' ks 'or' ks 'equal' ks 'to'    /nw { return RelevanceToken::t_notLessOrEqual; }
	'it'                                                            /nw { return RelevanceToken::t_it; }
	'item'                                                          /nw { return RelevanceToken::t_phraseItem; }
	'items'                                                         /nw { return RelevanceToken::t_phraseItems; }
	'mod'                                                           /nw { return RelevanceToken::t_mod; }
	'not'                                                           /nw { return RelevanceToken::t_not; }
	'number'                                                        /nw { return RelevanceToken::t_phraseNumber; }
	'of'                                                            /nw { return RelevanceToken::t_of; }
	'or'                                                            /nw { return RelevanceToken::t_or; }
	'starts' ks 'with'                                              /nw { return RelevanceToken::t_startsWith; }
	'then'                                                          /nw { return RelevanceToken::t_then; }
	'there' ks 'do' ks 'not' ks 'exist'                             /nw { return RelevanceToken::t_notExists; }
	'there' ks 'does' ks 'not' ks 'exist'                           /nw { return RelevanceToken::t_notExists; }
	'there' ks 'exist'                                              /nw { return RelevanceToken::t_exists; }
	'there' ks 'exist' ks 'no'                                      /nw { return RelevanceToken::t_notExists; }
	'there' ks 'exists'                                             /nw { return RelevanceToken::t_exists; }
	'there' ks 'exists' ks 'no'                                     /nw { return RelevanceToken::t_notExists; }
	'true'                                                          /nw { return RelevanceToken::t_true; }
	'whose'                                                         /nw { return RelevanceToken::t_whose; }

	'\000' { return RelevanceToken::t_endOfInput; }
	any    { return RelevanceToken::t_illegal; }
*/
}
