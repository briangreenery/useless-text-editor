
// To generate this file run: re2c -b -i -w RelevanceLexer.re2c > RelevanceLexer.cpp

#include "RelevanceLexer.h"

RelevanceLexer::RelevanceLexer()
{
	Reset();
}

void RelevanceLexer::Reset()
{
	m_start = 0;
	m_end = 0;
	m_cursor = 0;
	m_marker = 0;
	m_ctxmarker = 0;
}

RelevanceToken RelevanceLexer::NextToken()
{
	m_marker    = m_cursor;
	m_ctxmarker = m_cursor;

/*!re2c
	re2c:define:YYCTYPE      = UTF16::Unit;
	re2c:define:YYCURSOR     = m_cursor;
	re2c:define:YYLIMIT      = m_end;
	re2c:define:YYMARKER     = m_marker;
	re2c:define:YYCTXMARKER  = m_ctxmarker;
	re2c:define:YYFILL:naked = 1;
	re2c:define:YYFILL       = "{ Fill(); }";

	ws           = '\t' | '\r' | '\n' | ' ';
	ignored      = 'a' | 'an' | 'the';
	keywordspace = ws+ ( ignored ws+ )*;
	null         = [\000];
	nonword      = [^0-9a-zA-Z_'] | null;
	nw           = nonword;
	word         = [a-zA-Z_][0-9a-zA-Z_']*;
	any          = [^\000];

	ws+                { return RelevanceToken::t_whitespace; }
	[0-9]+             { return RelevanceToken::t_number; }
	["][^"\000]*["]    { return RelevanceToken::t_string; }
	["][^"\000]* /null { return RelevanceToken::t_unterminatedString; }

	word               { return RelevanceToken::t_word; }
	
	"("                { return RelevanceToken::t_openParen; }
	")"                { return RelevanceToken::t_closeParen; }
	
	"!="               { return RelevanceToken::t_notEqual; }
	"&"                { return RelevanceToken::t_concat; }
	"*"                { return RelevanceToken::t_star; }
	"+"                { return RelevanceToken::t_plus; }
	","                { return RelevanceToken::t_comma; }
	"-"                { return RelevanceToken::t_minus; }
	"/"                { return RelevanceToken::t_slash; }
	";"                { return RelevanceToken::t_semiColon; }
	"<"                { return RelevanceToken::t_less; }
	"<="               { return RelevanceToken::t_lessOrEqual; }
	"="                { return RelevanceToken::t_equal; }
	">"                { return RelevanceToken::t_greater; }
	">="               { return RelevanceToken::t_greaterOrEqual; }

	'a'                               /nw { return RelevanceToken::t_ignored; }
	'an'                              /nw { return RelevanceToken::t_ignored; }
	'the'                             /nw { return RelevanceToken::t_ignored; }

	'and'                             /nw { return RelevanceToken::t_and; }
	'as'                              /nw { return RelevanceToken::t_as; }
	'contains'                        /nw { return RelevanceToken::t_contains; }
	'does not contain'                /nw { return RelevanceToken::t_notContains; }
	'does not end with'               /nw { return RelevanceToken::t_notEndsWith; }
	'does not equal'                  /nw { return RelevanceToken::t_notEqual; }
	'does not start with'             /nw { return RelevanceToken::t_notStartsWith; }
	'else'                            /nw { return RelevanceToken::t_else; }
	'ends with'                       /nw { return RelevanceToken::t_endsWith; }
	'equals'                          /nw { return RelevanceToken::t_equal; }
	'exist'                           /nw { return RelevanceToken::t_exists; }
	'exist no'                        /nw { return RelevanceToken::t_notExists; }
	'exists'                          /nw { return RelevanceToken::t_exists; }
	'exists no'                       /nw { return RelevanceToken::t_notExists; }
	'false'                           /nw { return RelevanceToken::t_false; }
	'if'                              /nw { return RelevanceToken::t_if; }
	'is'                              /nw { return RelevanceToken::t_equal; }
	'is contained by'                 /nw { return RelevanceToken::t_containedBy; }
	'is equal to'                     /nw { return RelevanceToken::t_equal; }
	'is greater than'                 /nw { return RelevanceToken::t_greater; }
	'is greater than or equal to'     /nw { return RelevanceToken::t_greaterOrEqual; }
	'is less than'                    /nw { return RelevanceToken::t_less; }
	'is less than or equal to'        /nw { return RelevanceToken::t_lessOrEqual; }
	'is not'                          /nw { return RelevanceToken::t_notEqual; }
	'is not contained by'             /nw { return RelevanceToken::t_notContainedBy; }
	'is not equal to'                 /nw { return RelevanceToken::t_notEqual; }
	'is not greater than'             /nw { return RelevanceToken::t_notGreater; }
	'is not greater than or equal to' /nw { return RelevanceToken::t_notGreaterOrEqual; }
	'is not less than'                /nw { return RelevanceToken::t_notLess; }
	'is not less than or equal to'    /nw { return RelevanceToken::t_notLessOrEqual; }
	'it'                              /nw { return RelevanceToken::t_it; }
	'item'                            /nw { return RelevanceToken::t_phraseItem; }
	'items'                           /nw { return RelevanceToken::t_phraseItems; }
	'mod'                             /nw { return RelevanceToken::t_mod; }
	'not'                             /nw { return RelevanceToken::t_not; }
	'number'                          /nw { return RelevanceToken::t_phraseNumber; }
	'of'                              /nw { return RelevanceToken::t_of; }
	'or'                              /nw { return RelevanceToken::t_or; }
	'starts with'                     /nw { return RelevanceToken::t_startsWith; }
	'then'                            /nw { return RelevanceToken::t_then; }
	'there do not exist'              /nw { return RelevanceToken::t_notExists; }
	'there does not exist'            /nw { return RelevanceToken::t_notExists; }
	'there exist'                     /nw { return RelevanceToken::t_exists; }
	'there exist no'                  /nw { return RelevanceToken::t_notExists; }
	'there exists'                    /nw { return RelevanceToken::t_exists; }
	'there exists no'                 /nw { return RelevanceToken::t_notExists; }
	'true'                            /nw { return RelevanceToken::t_true; }
	'whose'                           /nw { return RelevanceToken::t_whose; }

	null { return RelevanceToken::t_endOfInput; }
	any  { return RelevanceToken::t_illegal; }
*/
}
